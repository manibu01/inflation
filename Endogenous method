from otree.api import *


doc = """
Your app description
"""


class C(BaseConstants):
    NAME_IN_URL = 'endo_inf'
    PLAYERS_PER_GROUP = None
    NUM_ROUNDS = 10


class Subsession(BaseSubsession):
    pass


class Group(BaseGroup):
    pass


class Player(BasePlayer):
    min_expectation = models.FloatField(
        label = "Was ist Ihre minimale Inflationserwartung? ")
    max_expectation = models.FloatField(
        label = "Was ist Ihre maximale Inflationserwartung? ")
    mid_point = models.FloatField()
    question = models.StringField(
        choices=["A", "B"],
        label=""
    )
    range = models.FloatField()


# FUNCTIONS
def midpoint(player: Player):
    # Funktion, die den midpoint ausrechnet und dabei je nach Antwort des Players entweder min oder max mit dem vorherigen midpoint ersetzt (bisection method)
    if player.round_number == 1:
       player.mid_point = (player.min_expectation + player.max_expectation) / 2
    else:
        if player.in_round(player.round_number - 1).question == "A":
            player.max_expectation = player.in_round(player.round_number - 1).mid_point
            player.min_expectation = player.in_round(player.round_number - 1).min_expectation
            player.mid_point = (player.min_expectation + player.max_expectation) / 2
        else:
            player.min_expectation = player.in_round(player.round_number - 1).mid_point
            player.max_expectation = player.in_round(player.round_number - 1).max_expectation
            player.mid_point = (player.min_expectation + player.max_expectation) / 2
    return player.mid_point


def range(player: Player):
    player.range = player.max_expectation - player.min_expectation
    return player.range
# def range(player: Player):
#     if player.round_number == 1:
#         player.range = player.max_expectation - player.min_expectation
#     else:
#         if player.in_round(player.round_number - 1).question == "A":
#             player.max_expectation = player.in_round(player.round_number - 1).mid_point
#             player.min_expectation = player.in_round(player.round_number - 1).min_expectation
#             player.range = player.max_expectation - player.min_expectation
#         else:
#             player.min_expectation = player.in_round(player.round_number - 1).mid_point
#             player.max_expectation = player.in_round(player.round_number - 1).max_expectation
#             player.range = player.max_expectation - player.min_expectation
#     return player.range


# PAGES
class InflationsErwartung(Page):
    # Spieler werden in Runde 1 nach Inflationserwartung gefragt
    form_model = "player"
    form_fields = ["min_expectation", "max_expectation"]

    @staticmethod
    def is_displayed(player: Player):
        return player.round_number == 1

    @staticmethod
    def error_message(player: Player, values):
        if values['min_expectation'] > values['max_expectation']:
            return 'Ihre minimale Inflationserwartung darf nicht größer als Ihre maximale Inflationserwartung sein.'
        elif values['min_expectation'] == values['max_expectation']:
            return 'Minimale und maximale Inflationserwartung dürfen nicht gleich sein.'

    @staticmethod
    def before_next_page(player: Player, timeout_happened):
        return range(player)

class Bisection(Page):
    form_model = "player"
    form_fields = ["question"]

    @staticmethod
    def is_displayed(player: Player):
        if player.round_number == 1:
            return player.range >= 1.5
        else:
            return player.in_round(player.round_number - 1).range >= 1.5

    @staticmethod
    def vars_for_template(player: Player):
        return dict(
            min_expectation = player.in_round(1).min_expectation,
            max_expectation = player.in_round(1).max_expectation,
            mid_point=midpoint(player),
            range = range(player)
            )
        # else:
        #     return dict(
        #         min_expectation=player.in_round(player.round_number-1).min_expectation,
        #         max_expectation=player.in_round(player.round_number-1).max_expectation,
        #         mid_point=midpoint(player),
        #         range=range(player)
        #     )

    @staticmethod
    def before_next_page(player: Player, timeout_happened):
        return range(player)

class Results(Page):

    @staticmethod
    def is_displayed(player: Player):
        return player.range <= 1.5


    @staticmethod
    def vars_for_template(player: Player):
        return dict(
            min_expectation=player.in_round(1).min_expectation,
            max_expectation=player.in_round(1).max_expectation,
            mid_point=player.mid_point
            )


page_sequence = [InflationsErwartung, Bisection, Results]
